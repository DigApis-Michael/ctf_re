### x86基本寄存器
介绍一下x86寄存器（32位机）的学习和用法。
相同的是：
32位CPU所含有的寄存器有：
+ 4个数据寄存器(EAX、EBX、ECX和EDX)
+ 2个变址和指针寄存器(ESI和EDI) 2个指针寄存器(ESP和EBP)
+ 6个段寄存器(ES、CS、SS、DS、FS和GS)
+ 1个指令指针寄存器(EIP) 1个标志寄存器(EFlags) 
#### 进制数
+ 十进制：汇编器默认的数制，也是我们日常表示数字的形式
+ 十六进制数：汇编程序中最常用的数制，表示形式：0[16进制数]h，前缀0可以省略
+ 二进制数：机器语言的表述形式，缺点是难读；表示形式：[二进制数]b
+ 八进制数：不是很常用，典型例子是unix的文件属性，逢八进一；表示形式：[八进制数]q/Q/O/o;
+ ***调试器默认使用十六进制表示整数***

#### x86的简单指令
+ reg32，32位寄存器，eg：EAX、EBX
+ reg16，16位寄存器，eg：AX，BX
+ reg8，8位寄存器，eg:AL，BH
+ imm32，32-bit立即数（常数）。
+ imm16，16-bit立即数。
+ imm8， 8-bit立即数。
##### 一些基本的指令
学习或者查阅指令时，用”汇编金手指“会比较方便
1、mov指令
+ 数据传送指令 MOV
+ 格式: MOV OPRD1,OPRD2
+ 功能: 本指令将一个源操作数送到目的操作数中,即OPRD1<--OPRD2.

2、xchg
+ 数据交换指令 XCHG
+ 格式: XCHG OPRD1,OPRD2 其中的OPRD1为目的操作数,OPRD2为源操作数
+  功能: 将两个操作数相互交换位置,该指令把源操作数OPRD2与目的操数OPRD1交换. 

3、inc、dec
+ inc 递增指令（加一）
+ dec 递减指令（减一）

4、add
+ 加法指令，格式  ADD OPRD1,OPRD2；两数相加并将结果送回OPRD1；
+  OPRD1为任一通用寄存器或存储器操作数,可以是任意一个通用寄存器,而且还可以是任意一个存储器操作数.这给程序的编写带来了很大的方便. 
OPRD2为立即数,也可以是任意一个通用寄存器操作数.立即数只能用于源操作数

5、lea
+  目标地址传送指令：将一个近地址指针写入到指定的寄存器。
+  格式：lea reg16,mem16
+  eg：lea ax,buf		;将存储器buf所指的地址传送给ax
+  注意点：reg16必须是一个16位的通用寄存器，mem16必须是一个存储器。执行完这个指令后，就讲mem16所指的16位偏移地址传送到了reg16中。**MOV指令传送的是地址所指的内容，而LEA只是传地址**

6、rep、stos
+ REP指令的作用是重复上面的指令，ECX的值是重复次数。 STOS指令是将EAX中的值拷贝到一个目的地址中。
+ 实例：
```
lea edi,[ebp-0C0h]
mov ecx,30h
mov eax,0CCCCCCCCh
rep stos dword ptr es:[edi]
```
+ rep格式：REP指令可以是任何字符串指令（CMPS、LODS、MOVS、SCAS、STOS）的前缀。 REP能够引发其后的字符串指令被重复，只要ECX的值不为0，重复就会继续。每一次字符串指令执行后，ECX的值都会减小。
+ STOS(store into string)意思是把EAX的内容拷贝到一个目的地址。 用法：stos dst，dst是一个目的地址，例如stos dword ptr es:[edi]。dword ptr（强制转换成dword格式）前缀是告诉stos，一次拷贝双字（4个字节）到目的地址。

#### 逻辑运算
##### 一些标志位
1、进位标志CF(Carry Flag)
进位标志CF主要用来反映运算是否产生进位或借位。如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。
使用该标志位的情况有：多字(字节)数的加减运算，无符号数的大小比较运算，移位操作，字(字节)之间移位，专门改变CF值的指令等。

2、奇偶标志PF(Parity Flag)
奇偶标志PF用于反映运算结果中“1”的个数的奇偶性。如果“1”的个数为偶数，则PF的值为1，否则其值为0。
利用PF可进行奇偶校验检查，或产生奇偶校验位。在数据传送过程中，为了提供传送的可靠性，如果采用奇偶校验的方法，就可使用该标志位。

3、辅助进位标志AF(Auxiliary Carry Flag)
在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0：
(1)、在字操作时，发生低字节向高字节进位或借位时；
(2)、在字节操作时，发生低4位向高4位进位或借位时。

4、零标志ZF(Zero Flag)
零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。

5、符号标志SF(Sign Flag)
符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。在微机系统中，有符号数采用补码表示法，所以，SF也就反映运算结果的正负号。运算结果为正数时，SF的值为0，否则其值为1。

6、溢出标志OF(Overflow Flag)
溢出标志OF用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。 

对以上6个运算结果标志位，在一般编程情况下，标志位CF、ZF、SF和OF的使用频率较高，而标志位PF和AF的使用频率较低。
##### cmp指令
      cmp（compare）指令比较两个操作数的大小， 对两数进行相减,进行比较.，但结果不会影响两个操作数的值，只会影响flag的CF、ZF、OF、AF、PF。 
+  OPRD1为任意通用寄存器或存储器操作数.
OPRD2为任意通用寄存器或存储器操作数,立即数也可用作源操作数OPRD2.
***以CMP DX,CX为例***,对标志位的影响如下:
+ (1) (DX)=(CX)时,则ZF=1;
+ (2) 两相无符号数比较:
   ```若(DX)>=(CX)时,则CF=0,即无借位.
        若(DX)<(CX)时,则CF=1. 
   ```
+ (3) 两个带符号数比较
        对带符号数判断大小可通过溢出标志OF及符号标志SF共同判断.
        ```  当 OF=0,即无溢出时,若SF=0,则(DX)>(CX)
                 若SF=1,则(DX)<(CX)
        当 OF=1,即有溢出时,若SF=1,则(DX)>(CX) 
                  若SF=0,则(DX)<(CX)
         ```
               
参考：
http://laokaddk.blog.51cto.com/368606/284280/

#### 跳转指令
1、无条件跳转：JMP
2、根据CX、ECX寄存器的值跳转：JCXZ（CX为0则跳转）、JECXZ（ECX为0则跳转）
3、根据EFLAGS寄存器的标志位跳转
···
JE   ;等于则跳转
JNE  ;不等于则跳转
JZ   ;为 0 则跳转
JNZ  ;不为 0 则跳转
JS   ;为负则跳转
JC   ;进位则跳转
JO   ;溢出则跳转
JA   ;无符号大于则跳转
JAE  ;无符号大于等于则跳转
JG   ;有符号大于则跳转
JGE  ;有符号大于等于则跳转
JB   ;无符号小于则跳转
JBE  ;无符号小于等于则跳转
JL   ;有符号小于则跳转
JLE  ;有符号小于等于则跳转
JP   ;奇偶位置位则跳转
JPE  ;奇偶位相等则跳转

#### 实模式与保护模式
从80386开始，cpu有三种工作方式：实模式，保护模式和虚拟8086模式。
+ 实模式：实模式只能访问地址在1M以下的内存称为常规内存，我们把地址在1M 以上的内存称为扩展内存。
+ 保护模式：全部32条地址线有效，可寻址高达4G字节的物理地址空间
+ 虚拟8086模式：运行在保护模式中的实模式，为了在32位保护模式下执行纯16位程序。它不是一个真正的CPU模式，还属于保护模式。
在64位奔腾4

#### 作业：
把寄存器全部设置成0的状态，然后执行下面的代码：
```
mov eax,0a1234h		;将十六进制数0a1234h送入eax
mov bx,ax			;将ax内容送入bx
mov ah,bl			;将bl内容送入ah
mov al,bh			;将bh内容送入al 
```
思考此时EAX的内容是多少?

EAX为32位寄存器。而AX即为EAX值的低16位；其中ah、al为八位寄存器，为AX的高八位和低八位。
```
0a1234h -->1010 0001 0010 0011 0100
则AX=0001 0010 0011 0100
BX=0001 0010 0011 0100
BH=0001 0010
BL=0011 0100
则AH=BL=0011 0100
AL=BH=0001 0010
则AX=0011 0100 0001 0010
则EAX=1010  0011 0100 0001 0010=0a3412
所以EAX=0a3412
```

