X86寄存器（32位）
=
**进制：**  
```
1. 十六进制：0x11111111或用11111111h（0x和h都是表示16进制,从0-f）  
2. 二进制：0101010b(只有0和1，用b表示)  
3. 八进制：777q（用q表示）  
```
**寄存器**  
```
1.32位的通用寄存器有：EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI  
2.16位的通用寄存器有：AX,CX,DX,BX,SP,BP,SI,DI  
3.8位的通用寄存器有：AH,CH,DH,BH,AL,CL,DL,BL  
```
**立即数**  
```
eg.  
imm32:0x12345678(32位的立即数）  
imm16:0x1234(16位的立即数）  
imm8：0x12(8位的立即数）  
```
**指令**   
*mov指令* **(注意数据宽度，且不能mov 内存,内存;)**  
```
mov eax,0x12345678 将0x12345678放进eax寄存器里  
mov ebx,0xaaaaaaaa 将0xaaaaaaaa放进ebx寄存器里  
mov eax,ebx 将ebx里的内容放进eax里，此时eax里的值应为0xaaaaaaaa  
```  
*xchg指令*  
就是交换数据,宽度要一样  
```
xchg reg32,reg32  
xchg reg16,reg16  
xchg reg8,reg8
xchg m,m  
eg.  
xchg ebx,ecx  表示ebx与ecx的数值被交换  
```  
*递增递减指令*  
```
inc reg(8,16,32)  递增  
dec reg(8,16,32)  递减
```  
*add指令*
```
eg.  
mov eax,0x11111111  //把0x11111111放进eax里  
add eax,0x22222222  //即把0x22222222和eax里的0x111111111相加，并且放到eax里  
也可以寄存器里的数值加立即数，另一寄存器里的数值或者说内存的数值。但要注意数据宽度。   
```  
*sub指令*  
```
同add指令  
```  
*lea指令*  
 ```
 将源操作数给出的有效地址传送到指定的的寄存器中  
 eg.  
 lea eax,dword ptr ds:[0x12345678]  //此时eax的值为0x12345678  
 !!与MOV指令不同  
 mov eax,dword ptr ds:[0x12345678]  //这是把内存地址为0x12345678里的数值放进eax里  
 ```  
 *rep、stos指令*  
 rep指令是重复上面的指令，ecx是重复次数，stos是将eax的值复制到一个目的地址中。  
```
lea edi,[ebp-0C0h]  //0C0h就是0xc0h  
mov ecx,30h  
mov eax,0cccccccch  
rep stos dword ptr es:[edi]  
```
*逻辑运算*  
```
and：两个都为1的时候才为1  
or：有一个1就为1  
xor：两个不相同才为1  
not：取反，1变0，0变1  
test：跟and指令类似，两个都为1的时候才为1，但是不修改运算数，只改变标志寄存器，常用到它对ZF的影响。  
```
*cmp指令*  
cmp指令比较两个操作数的大小，进行的运算是第一个操作数减去第二个操作数，但结果不会影响两个操作数的值，只会影响CF、ZF、OF、AF、PF。  
对各个标志位的影响如下：  
```
若执行cmp后  
ZF=1,即操作数1-操作数2=0，则两个操作数相同。  
当无符号时：  
若CF=1的话则说明有借位了，所以此时操作数1<操作数2  
若CF=0，则说明无借位。不过要考虑ZF是否为0，如果是0的话，则说明了操作数1>操作数2  
当有符号时：  
若SF=0,OF=0,则说明了此时的值为正数，没有溢出，可以看出操作数1>操作数2 eg.00001000-00000111=00000001  
若SF=1,OF=o,则说明了此时的值为负数，没有溢出，可以看出操作数1<操作数2 eg.00000111-00001000=11111111  
若SF=0,OF=1，则说明了此时的值为正数，有溢出，可以看出操作数1<操作数2  ？有例子吗？  
若SF=1，OF=1,则说明了此时的值为负数，有溢出，可以看出操作数1>操作数2  ？有例子吗？  
正正得负则溢出，负负得正则溢出，正负是不会有溢出的。  
```  
*跳转指令*  
跳转指令分三类：  
 1. 无条件跳转：JMP  
 2. 根据CX、ECX寄存器的值跳转：JCXZ（CX为0则跳转）、JECXZ（ECX为0则跳转）  
 3. 根据EFLAAGS寄存器的标志位跳转，列表如下：  
 ```
 JE   ;等于则跳转
	JNE  ;不等于则跳转

	JZ   ;为 0 则跳转
	JNZ  ;不为 0 则跳转

	JS   ;为负则跳转
	JNS  ;不为负则跳转

	JC   ;进位则跳转
	JNC  ;不进位则跳转

	JO   ;溢出则跳转
	JNO  ;不溢出则跳转

	JA   ;无符号大于则跳转
	JNA  ;无符号不大于则跳转
	JAE  ;无符号大于等于则跳转
	JNAE ;无符号不大于等于则跳转

	JG   ;有符号大于则跳转
	JNG  ;有符号不大于则跳转
	JGE  ;有符号大于等于则跳转
	JNGE ;有符号不大于等于则跳转

	JB   ;无符号小于则跳转
	JNB  ;无符号不小于则跳转
	JBE  ;无符号小于等于则跳转
	JNBE ;无符号不小于等于则跳转

	JL   ;有符号小于则跳转
	JNL  ;有符号不小于则跳转
	JLE  ;有符号小于等于则跳转
	JNLE ;有符号不小于等于则跳转

	JP   ;奇偶位置位则跳转
	JNP  ;奇偶位清除则跳转
	JPE  ;奇偶位相等则跳转
	JPO  ;奇偶位不等则跳转  
```  
**实模式与保护模式**  
Intel 80386只有进入保护模式后，才能充分发挥其强大的功能，提供更好的保护机制和更大的寻址空间，否则仅仅是一个快速的8086而已。没有一定的保护机 制，任何一个应用软件都可以任意访问所有的计算机资源，这样也就无从谈起操作系统设计了。  
*模式种类*  
1.实模式  实模式只能访问地址在1M以下的内存称为常规内存  
2.保护模式  
3.虚拟8086模式  虚拟8086模式是运行在保护模式中的实模式  
**保护模式同实模式的根本区别是进程内存受保护与否**  
  
**64位奔腾4处理器工作模式**  
三种基本模式：  
1.保护模式：纯32位保护执行环境。  
2.实模式：纯16位无保护执行环境。  
3.统管理模式：当SMI引脚为有效进入系统管理模式，首先保存当前的CPU上下文。它有独立的地址空间，用来执行电源管理或系统安全方面的指令。  
扩展模式：  
IA-32e模式，64位操作系统运行在该模式。  
子模式：1.兼容模式：该模式下，64位操作系统运行在32位兼容环境，能正常运行16，32位应用程序就像基本的保护模式一样，访问32位地址空间，但不能运行纯16位实模式程序（就是不能运行虚拟86模式程序了）。  
       2.64位模式：在该模式下，处理器完全执行64位指令，使用64位地址空间和64操作数，运行16，32位程序必须切换到兼容模式。  
     
作业
=
把寄存器全部设置成0的状态，然后执行下面的代码：  
  
mov eax,0a1234h			;将十六进制数0a1234h送入eax  //eax:0xa1234  
mov bx,ax			;将ax内容送入bx  //bx:0x1234  
mov ah,bl			;将bl内容送入ah  //ah:0x34  
mov al,bh			;将bh内容送入al  //al:0x12  
思考此时EAX的内容是多少?  
此时EAX的内容应该是0xa3412。

