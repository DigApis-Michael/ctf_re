### 20180204-02
# X86寄存器说明
32位CPU所含有的寄存器有：<br>
4个数据寄存器(EAX、EBX、ECX和EDX)<br>
2个变址和指针寄存器(ESI和EDI) 2个指针寄存器(ESP和EBP)<br>
6个段寄存器(ES、CS、SS、DS、FS和GS)<br>
1个指令指针寄存器(EIP) 1个标志寄存器(EFlags) <br>

# 汇编语言中的整数常量表示
二进制（汇编程序常用）<br>
八进制（汇编程序不常用）<br>
十进制（汇编器默认的数制）<br>
十六进制（汇编程序最常用）<br>

### 简单指令
1、 reg32，32-bit寄存器，如EAX、EBX等。<br>
2、reg16，16-bit寄存器，如AX，BX等。<br>
3、reg8？，8-bit寄存器，如AL，BH等。   <br>
4、 imm32，32-bit立即数，可以理解为常数。<br>
5、imm16，16-bit立即数。<br>
6、imm8？ 8-bit立即数。<br>

MOV指令<br>
格式：mov reg32，（reg32，imm8，imm16，imm32）<br>
mov reg16，（reg16，imm8，imm16）<br>
mov reg8，（reg8，imm8）<br>
将数据发送到寄存器中010h<br>
eg: <br>
mov eax,ebx; 将ebx的内容送入eax<br>
mov eax,010h;在EAX寄存器中载入<br>

xchg指令<br>
xchg regxx,regxx（此处的xx为数字，可为8,16,32）<br>
eg：xchg ebx,ecx，表示ebx与ecx的数值被交换。<br>

递增指令<br>
inc：递增指令（加1）<br>
dec：递减指令（减1）<br>

add指令<br>
将寄存器的数值与另一寄存器或立即数的值相加，并存回寄存器<br>
格式：ADD POOD1，OPPD2;<br>
 OPRD1为任一通用寄存器或存储器操作数,OPRD2为立即数,也可以是任意一个通用寄存器操作数.立即数只能用于源操作数.<br>
OPRD1和OPRD2均为寄存器是允许的,一个为寄存器而另一个为存储器也是允许的, 但不允许两个都是存储器操作数<br>

lea指令<br>
将近地址指针写入到指定的寄存器
格式：lea oprd1,oprd2;<br>
OPRD1 为目的操作数,可为任意一个16位的通用寄存器.OPRD2 为源操作数,可为变量名、标号或地址表达式
eg：lea ax,buf;将存储器buf所指地址传送给ax<br>
mov所传送的是地址所指的内容，而lea只是传地址<br>

rep、stos指令<br>
rep：重复上面的指令，ECX的值是重复次数。<br>
rep指令可以是任何字符串指令的前缀，每重复一次，ECX的值都会减小<br>
stos：将EAX的值拷贝到一个目的地址中<br>
格式： stos dst；dst是一个目的地址<br>

cmp指令
比较两个操作数的大小，进行的运算为第一个操作数减去第二个操作数，但是结果不会影响两个操作数的值。

 
# 逻辑运算指令
AND：该指令会置 CF=OF=0; 其结果影响 SF、ZF、PF；指令格式:AND r/m, r/m/i<br>
OR：该指令会置 CF=OF=0; 其结果影响 SF、ZF、PF
;指令格式:OR r/m, r/m/i<br>
XOR：该指令会置 CF=OF=0; 其结果影响 SF、ZF、PF
;指令格式:XOR r/m, r/m/i<br>
NOT：该指令不影响 EFlags;指令格式:NOT r/m<br>
TEST：该指令会置 CF=OF=0; 其结果影响 SF、ZF、PF
;指令格式:TEST r/m, r/m/i<br>
详情：http://blog.csdn.net/betabin/article/details/7306347 <br>
OF 溢出标志   ：运算时，若操作数超出了机器所能表示的范围为，则产生溢出,OF=1，否则OF=0<br>
SF 符号标志    ;设置成运算操作结果的符号状态。当结果为负时，SF=1,否则SF=0<br>
ZF 零标志 结果=0,ZF=1,结果≠0,ZF=0<br>
AF 辅助进位标志 ,运算过程中第三位有进位,置AF=1,否则AF=0<br>
PF 奇偶标志： 当操作数中有偶数个1时，置PF=1,否则PF=0<br>
CF进位标志 : 最高有效位产生的进位值，例如 执行加法指令时，MSB有进，置CF=1；否则CF=0<br>
控制标志:控制执行特殊的功能<br>
DF放向标志：用于字符串操作指令程序设计。<br>
DF置0，则串操作控制处理方向，从带有最低地址的第一个元素逐个处理，否则，从高向低<br>
ID中断允许标志: IF=1,CPU允许中断，IF=0，则CPU关闭中断<br>
TF跟踪标志:TF=1，机器进入单步工作方式，每条机器指令执行后，显示结果及寄存器状态，若TF=0，则机器处在连续工作方式。此标志为调试机器或调试程序发现故障而设置。<br>
具体判断<br>
SF：运算结果为负时置1，为正则清零；<br>
也就是说，它与运算结果的最高位相同。<br>
OF：有符号数运算溢出时置1，不溢出则清零；<br>
比如同号相加结果变号，或者正数减负数结果是负数（异号相减结果与减数相同）<br>
CF：无符号数运算有进位或借位时置1，否则清零；<br>
看最高位的进位，借位，这最容易理解。<br>
ZF：结果为0时置1，结果不是0则清零。<br>

跳转指令<br>
1、无条件跳转：JMP<br>
2、根据CX、ECX寄存器的值跳转：JCXZ（CX为0则跳转）、JECXZ（ECX为0则跳转）<br>
3、根据EFLAGS寄存器的标志位跳转，其规则为：<br>

![Alt text](1517724936258.png)
![Alt text](1517724972929.png)

### 模式区别
【实模式】 将整个物理内存看成分段的区域,程序代码和数据位于不同区域，系统程序和用户程序没有区别对待，而且每一个指针都是指向"实在"的物理地址。<br>
【保护模式】 物理内存地址不能直接被程序访问，程序内部的地址（虚拟地址）要由操作系统转化为物理地址去访问，程序对此一无所知。<br>

把寄存器全部设置成0的状态，然后执行下面的代码：<br>

mov eax,0a1234h			;将十六进制数0a1234h送入eax<br>
mov bx,ax			;将ax内容送入bx<br>
mov ah,bl			;将bl内容送入ah<br>
mov al,bh			;将bh内容送入al<br>

思考此时EAX的内容是多少?<br>
EAX为32位寄存器，AX位低16位，ah、al为高八位与低八位<br>
运用进制转换将0a1234h转换为二进制<br>
1010 0001 0010 0011 0100<br>
EAX=1010 0001 0010 0011 0100<br>
bx=ax=0001 0010 0011 0100<br>
ah=bl=0011 0100<br>
al=bh=0001 0010<br>
EAX=1010 0011 0100 0001 0010<br>

