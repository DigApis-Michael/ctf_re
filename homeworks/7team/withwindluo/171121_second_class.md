## 汇编语言的整数常量表示
#### 十进制整数
 汇编器的默认数制。数字表示：`[十进制数]d` 或者 `[十进制数]D`。

#### 十六进制数
 汇编程序如OD中常用的数制，数字表示：`0[十六进制数]h` 或者`0[十六进制数]H`。如果第一位是数字，则开头的0可以省略。如`1234h`,`0abcdh`。
 
#### 二进制数
常用的数制，数字表示:`[二进制数]b`或`[二进制数]B`。4位二进制数可以对应以为1位十六进制数。

#### 八进制数
很少用的数制，Unix的文件属性会甬道。数字表示：`[八进制数]q`、`[八进制数]Q`、`[二进制数]o`或`[二进制数]O`。**调试器默认使用十六进制表示整数**。

|二进制|八进制|十进制|十六进制|
|:----:|:---:|:---:|:-----:|
|[二进制数]b|[八进制数]q|[十进制数]d|0[十六进制数]h|
|[二进制数]B|[八进制数]Q|[十进制数]D|0[十六进制数]H|
|\|[二进制数]o|\|\|
|\|[二进制数]O|\|\|


## 简单指令
#### 约定
1. reg32,32位寄存器，如EAX,EBX等等。
2. reg16,16位寄存器，如AX,BX等等。
3. reg8 ,8位寄存器，如AL,BH等等。
4. imm32,32位立即数。
5. imm16,16位立即数。
6. imm8,8位立即数。

#### MOV指令（move的缩写）
该指令可以将数据发送到寄存器中。
 mov `源操作数`,`目的操作数`;
`mov reg32,(reg32,imm8,imm16,imm32)`
`mov reg16,(reg16,imm8,imm16)`
`mov reg 8,(reg8,imm8)`

例子：
mov EAX,1234H;
mov EAX,EBX;

#### xchg指令
`xchg reg32,reg32`
`xchg reg16,reg16`
`xchg reg8,reg8`

例如`xchg eax,ecx`表示将eax与ecx的数值进行交换。

#### 递增（减）指令
`inc reg(8,16,32)`
`dec reg(8,16,32)`

#### add/sub指令
`add/sub reg32,reg32/imm(8,16,32)`
`add/sub reg16,reg16/imm(8,16)`
`add/sub reg8,reg8/imm(8)`
将寄存器的数值与另一寄存器或者立即数相加，并存回原来的寄存器中。

#### lea指令
目的地址传送指令：将一个近地址的指针写入到指定的寄存器。(获取内存编号)
如：`lea reg16,mem16`
`lea eax,dword ptr ds:[ESP]`

#### rep、stos指令
- rep 按计数寄存器(ECX)中指定的次数重复执行字符串指令
- stos 将AL/AX/EAX的值存储到[EDI]指定的内存单元
`stos byte ptr es:[edi]`  简写STOSB
`stos word ptr es:[edi]`  简写STOSW
`stos dword ptr es:[edi]` 简写STOSD
rep可配合stos使用，用于堆栈的操作。
- rep能够引发其后的字符串指令被重复，只要ECX不为0，重复就继续。
每一次执行字符串指令之后，ECX的值都会减小。
- 标志寄存器D位可以改变EDI的增长方向：DF为0则加，DF为1则减。

## 逻辑运算
- ##### AND: 逻辑与
 - 转换为二进制，两个对应位都为1时，结果的对应位才为1，否则为0；
 - 该指令会置 CF=OF=0;其结果影响SF、ZF、PF。
 - 指令格式:`AND r/m,r/m/i`
 ** 运用例子**：
   1.将特定的位清零
   2.将字母转大写（因为大小写字幕只有第五位不同）
   
- ##### OR: 逻辑或
 - 转换为二进制，两个对应位有一个为1时，结果的对应位为1，否则为0；
 - 该指令会置 CF=OF=0; 其结果影响 SF、ZF、PF；
 - 指令格式:`OR r/m, r/m/i`
** 运用例子**
   1.确保特定位为1
   2.将字母转大写（因为大小写字幕只有第小位不同）

- ##### XOR:逻辑异或
 - 转换为二进制，两个对应位不同时，结果的对应位为1，否则为0；
 - 该指令会置 CF=OF=0; 其结果影响 SF、ZF、PF；
 - 指令格式:`XOR r/m, r/m/i`
  ** 运用例子**：
   1.两次xor一个相同的数 XOR 恢复到原来的数
   2.使用 XOR 加密与解密字符串(运用第一个例子)
   3.清空某个寄存器：`xor eax,eax`
   
- ##### NOT: 逻辑取反
  - 转换为二进制，0和1全部取反
  - 该指令不影响 EFlags
  - 指令格式:`NOT r/m`
   运用例子：
  1.使用 NOT 加密与解密字符串
  
- ##### TEST: 测试逻辑与
 - TEST同AND, 但它不修改运算数, 只改变标志寄存器; 也就是尝试AND的结果
 - 常用到它对 ZF 的影响(结果为0时ZF=1)
 - TEST 之后常常跟着条件跳转指令 JZ、JNZ
 - 指令格式:`TEST r/m, r/m/i`
  1.根据ZF位判断某一位是否为0，如最后一位 `test al,00000001b`
  2.判断某寄存器是否为空,`test eax,eax`,若ZF=1，则为空
  
## cmp指令与JCC跳转指令
- ##### cmp指令
 - cmp（compare）指令比较两个操作数的大小，进行的运算是第一个操作数减去第二个操作数，但结果不会影响两个操作数的值，只会影响flag的CF、ZF、OF、AF、PF。
 - ZF=1 则说明两个数相等，因为zero为1说明结果为0
 - 对各个flag的影响如下(若执行指令后)：
   - 当无符号时：
     - CF=1 则说明了有进位或借位，cmp是进行的减操作，故可以看出为借位，所以，此时oprd1<oprd2 
	 - CF=0 则说明了无借位，但此时要注意ZF是否为0，若为0，则说明结果不为0，故此时oprd1>oprd2
   - 当有符号时：
     - 若SF=0，OF=0 则说明了此时的值为正数，没有溢出，可以直观的看出，oprd1>oprd2
     - 若SF=1，OF=0 则说明了此时的值为负数，没有溢出，则为oprd1<oprd2
     - 若SF=0，OF=1 则说明了此时的值为正数，有溢出，可以看出oprd1<oprd2
     - 若SF=1，OF=1则说明了此时的值为负数，有溢出，可以看出oprd1>oprd2
   - 最后两个可以作出这种判断的原因是，溢出的本质问题：
     - 两数同为正，相加，值为负，则说明溢出
     - 两数同为负，相加，值为正，则说明溢出
     - 故有，正正得负则溢出，负负得正则溢出
- ##### 跳转指令
  -  跳转指令分三类：
  1.无条件跳转：JMP
  2.根据CX、ECX寄存器的值跳转：JCXZ（CX为0则跳转）、JECXZ（ECX为0则跳转）
  3.根据EFLAGS寄存器的标志位跳转，列表如下：



| JCC指令  | 中文含义  |英文原意   | 检查符号位  |典型C应用  |
| ------------ | ------------ | ------------ | ------------ | ------------ |
| JZ/JE  |若为0则跳转；若相等则跳转|jump if zero;jump if equal |ZF=1   |if (i == j);if (i == 0); |
|JZ/JE	|若为0则跳转；若相等则跳转	|jump if zero;jump if equal	|ZF=1	|if (i == j);if (i == 0);|
|JNZ/JNE|若不为0则跳转；若不相等则跳转	|jump if not zero;jump if not equal	ZF=0|	if (i != j);|if (i != 0);|
|JS	|若为负则跳转	|jump if sign	|SF=1	|if (i < 0);|
|JNS	|若为正则跳转	|jump if not sign	|SF=0	|if (i > 0);|
|JP/JPE	|若1出现次数为偶数则跳转|	jump if Parity (Even)|	PF=1|	(null)|
|JNP/JPO|	若1出现次数为奇数则跳转|	jump if not parity (odd)|	PF=0|	(null)|
|JO	|若溢出则跳转	|jump if overflow|	OF=1	|(null)|
|JNO	|若无溢出则跳转	|jump if not overflow	|OF=0|	(null)
|JC/JB/JNAE|	若进位则跳转；若低于则跳转；若不高于等于则跳转	|jump if carry;jump if below;jump if not above equal	|CF=1	|if (i < j);|
|JNC/JNB/JAE|	若无进位则跳转；若不低于则跳转；若高于等于则跳转；|	jump if not carry;jump if not below;jump if above equal	|CF=0|	if (i >= j);|
|JBE/JNA|	若低于等于则跳转；若不高于则跳转	|jump if below equal;jump if not above	|ZF=1或CF=1	|if (i <= j);|
|JNBE/JA|	若不低于等于则跳转；若高于则跳转|	jump if not below equal;jump if above|	ZF=0或CF=0	|if (i > j);|
|JL/JNGE	|若小于则跳转；若不大于等于则跳转	|jump if less;jump if not greater equal|	SF != OF|	if (si < sj);|

## 模式
- ##### 实模式与保护模式
为何要了解Intel 80386的保护模式和分段机制？首先，我们知道Intel 80386只有在进入保护模式后，才能充分发挥其强大的功能，提供更好的保护机制和更大的寻址空间，否则仅仅是一个快速的8086而已。没有一定的保护机 制，任何一个应用软件都可以任意访问所有的计算机资源，这样也就无从谈起操作系统设计了。且Intel 80386的分段机制一直存在，无法屏蔽或避免。其次，在我们的bootloader设计中，涉及到了从实模式到保护模式的处理，我们的操作系统功能（比 如分页机制）是建立在Intel 80386的保护模式上来设计的。如果我们不了解保护模式和分段机制，则我们面向Intel 80386体系结构的操作系统设计实际上是建立在一个空中楼阁之上。

- ##### 模式种类
从80386开始，cpu有三种工作方式：**实模式**，**保护模式**和**虚拟8086模式**。只有在刚刚启动的时候是real-mode，等到linux操作系统运行起来以后就运行在保护模式。 实模式只能访问地址在1M以下的内存称为**常规内存**，我们把地址在1M 以上的内存称为**扩展内存**。 在保护模式下，全部32条地址线有效，可寻址高达4G字节的物理地址空间;扩充的存储器分段管理机制和可选的存储器分页管理机制，不仅为存储器共享和保护提供了硬件支持，而且为实现虚拟存储器提供了硬件支持;支持多任务，能够快速地进行任务切换和保护任务环境;4个特权级和完善的特权检查机制，既能实现资源共享又能保证代码和数据的安全和保密及任务的隔离;支持虚拟8086方式，便于执行8086程序。 虚拟8086模式是运行在保护模式中的实模式，为了在32位保护模式下执行纯16位程序。它不是一个真正的CPU模式，还属于保护模式。

- ##### 模式区别
保护模式同实模式的根本区别是进程内存受保护与否 。可寻址空间的区别只是这一原因的果。 **【实模式】** 将整个物理内存看成分段的区域,程序代码和数据位于不同区域，系统程序和用户程序没有区别对待，而且每一个指针都是指向"实在"的物理地址。这样一来，用户程序的一个指针如果指向了系统程序区域或其他用户程序区域，并改变了值，那么对于这个被修改的系统程序或用户程序，其后果就很可能是灾难性的。为了克服这种低劣的内存管理方式，处理器厂商开发出保护模式。 **【保护模式】** 物理内存地址不能直接被程序访问，程序内部的地址（虚拟地址）要由操作系统转化为物理地址去访问，程序对此一无所知。 至此，进程（这时我们可以称程序为进程了）有了严格的边界，任何其他进程根本没有办法访问不属于自己的物理内存区域，甚至在自己的虚拟地址范围内也不是可以任意访问的，因为有一些虚拟区域已经被放进一些公共系统运行库。这些区域也不能随便修改，若修改就会有: SIGSEGV（linux 段错误）;非法内存访问对话框（windows 对话框）。 **【补充】** 保护模式下，有两个段表：GDT（Global Descriptor Table）和LDT（Local Descriptor Table），每一张段表可以包含8192 (2^13)个描述符[1]，因而最多可以同时存在2 * 2^13 = 2^14个段。虽然保护模式下可以有这么多段，逻辑地址空间看起来很大，但实际上段并不能扩展物理地址空间，很大程度上各个段的地址空间是相互重叠的。目 前所谓的64TB（2^(14+32)=2^46）逻辑地址空间是一个理论值，没有实际意义。在32位保护模式下，真正的物理空间仍然只有2^32字节那 么大。注：在ucore lab中只用到了GDT，没有用LDT。

- ##### 64位奔腾4处理器工作模式
事实上，现在的64位奔腾4处理器，拥有三种基本模式和一种扩展模式，
 1. 基本模式： 保护模式：纯32位保护执行环境。 实模式：纯16位无保护执行环境。 系统管理模式：当SMI引脚为有效进入系统管理模式，首先保存当前的CPU上下文。它有独立的地址空间，用来执行电源管理或系统安全方面的指令。
 2. 扩展模式： IA-32e模式，64位操作系统运行在该模式。 该模式有两种子模式: 1）兼容  模式：该模式下，64位操作系统运行在32位兼容环境，能正常运行16，32位应用程序就像基本的保护模式一样，访问32位地址空间，但不能运行纯16位实模式程序（就是不能运行虚拟86模式程序了）。 2）64位模式：在该模式下，处理器完全执行64位指令，使用64位地址空间和64操作数，运行16，32位程序必须切换到兼容模式。 IA-32e子模式的切换完全基于代码段寄存器。这样一来，运行在IA-32e模式中（64位）的OS完全可以无缝的运行所有16，32，64为应用程序，通过设置32位后的CS。
 
 
 ## 练习
 把寄存器全部设置成0的状态，然后执行下面的代码：
```
mov eax,0a1234h 	;将十六进制数0a1234h送入eax
mov bx,ax			;将ax内容送入bx
mov ah,bl			;将bl内容送入ah
mov al,bh			;将bh内容送入al
```
思考此时EAX的内容是多少?
![](https://github.com/WithWindLuo/ctf_web/blob/master/src/register.jpg?raw=true)
`mov eax,0a1234h`   EAX=000a1234h;
`mov bx,ax`         BX=1234h;
`mov ah,bl`         AH=34h;
`mov al,bh`         AL=BH=12h;
所以最后**EAX=000a3412h**
