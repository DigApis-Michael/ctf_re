# 源代码
![](https://github.com/clm136526/ctf_web/blob/master/src/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180116203811.png?raw=true)
# 使用IDA分析
![](https://github.com/clm136526/ctf_web/blob/master/src/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180116203814.png?raw=true)
- 从左边找到main函数进入
- 对下图进行分析(不完整)
![](https://github.com/clm136526/ctf_web/blob/master/src/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180116204201.png?raw=true)
> .text:00401340                 push ebp//保存上一个函数的栈底指针.退出内层函数的时候可以恢复调用者的调用栈.
> .text:00401349                 call main//调用主函数
> .text:0040134E                 mov     dword ptr [esp+1Ch], 1//dword   双字 就是四个字节
> .text:00401356                 mov     dword ptr [esp+18h], 2//ptr     pointer缩写 即指针
> .text:0040135E                 mov     dword ptr [esp+14h], 3//可知四个字节保存一个数字
> .text:00401366                 mov     eax, [esp+14h]//将[]字节里东西放入eax
> .text:0040136A                 mov     [esp+0Ch], eax//将eax放入[]字节中
> .text:0040136E                 mov     eax, [esp+18h]//达到参数传递
> .text:00401372                 mov     [esp+8], eax
> .text:00401376                 mov     eax, [esp+1Ch]
> .text:0040137A                 mov     [esp+4], eax
> .text:0040137E                 mov     dword ptr [esp], offset aDDD ; "%d %d %d"
> .text:00401385                 call    _printf//调用printf函数
> .text:0040138A                 mov     eax, 0//将0放入eax作为返回值
> .text:0040138F                 leave
> .text:00401390                 retn//返回
## 最后F5一下(查看源码)
![](https://github.com/clm136526/ctf_web/blob/master/src/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180116203817.png?raw=true)
