------------------------------------------------
## 第二次任务-划重点：

----
>**前情提要**

1. 汇编语言被编译成机器语言之后，将由处理器（CPU）来执行。

2. 典型处理器的主要任务

- 从内存中获取机器语言指令，译码，执行。
- 根据指令代码管理它自己的寄存器。
- 根据指令或自己的需要修改内存的内容。
- 响应其他硬件的中断请求。

3. 80386处理器上的通用寄存器如下图
![](https://camo.githubusercontent.com/35f51ec32b4ab2558fde0fc959d3c226ba3106fc/687474703a2f2f6d306e737433722e6d652f7573722f75706c6f6164732f323031372f31312f323930353138323336392e706e67)

  - 数字表示位
  - 32-bit寄存器EAX的低16位==AX
  - AX高8位==AH
  - AX低8位==AL
  
------
4. 通用寄存器的名称和习惯用法+指针相关

----
注：

i)前4个同EAX一样包括对应的16-bit 和8-bit分组

ii)后3个寄存器没有对应的8-bit分组。但可以通过SI、DI，BP分别访问他们的低16位。

iii)以下8寄存器都为32-bit

**通用寄存器**

|   名称   |       习惯用法       |     保护模式下     | DS（数据段） |
|:--------:|:------------------:|:----------------:|:----------------:|
|   EAX    |           运算          |作为内存偏移指针|保护模式下作为段寄存器或选择器|
|EBX|内存偏移指针|同左|是默认的段寄存器或选择器|
|ECX|特定指令的计数|以作为内存偏移指针|保护模式下作为寄存器或段选择器|
|EDX|在某些运算中作为EAX的溢出寄存器（例如乘、除）|作为内存偏移指针|保护模式下作为寄存器或段选择器|


----

- **ESI**：通常在内存操作指令中作为**源地址指针**使用。当然，ESI可以被装入任意的数制，但通常没有人把它当做通用寄存器来用。DS作为寄存器或段选择器。
- **EDI** :通常在内存操作指令中作为**目的地址指针**使用。
- **EBP** :作为**指针**的寄存器。通常，它被高级语言编译器用以建造堆栈帧来保存函数或过程的局部变量。SS（堆栈段或堆栈选择器）是它的默认段寄存器或选择器。

----
-  **IP**： Instruction Pointer，**指令指针**。 
- **SP**： Stack Pointer，**堆栈指针**。

----
5. 段寄存器和选择器

----
- 实模式下的段寄存器到保护模式下，摇身一变就成了选择器。不同的是，实模式下的段选择器是16-bit的，而保护模式下的选择器是32-bit的。


|实模式 |保护模式|
|:--------:|:----------:|
|寄存器|选择器|
|16-bit|32bit|


- **CS**，**代码段**，或代码选择器。同IP寄存器一同**指向当前正在执行的地址**。处理器执行时从这个寄存器指向的段（实模式）或内存（保护模式）中获取指令。除了跳转或其他分支指令外，你无法修改这个寄存器的内容。

- **DS**，**数据段**，或数据选择器。这个寄存器的低16-bit连同ESI（原地址指针）一同**指向指令将要执行的内存**。同时，所有的内存操作指令默认情况下都用它指定操作段（实模式）或内存（保护模式下作为选择器）。这个寄存器可被装入任意数值，做法是先把数据给AX，在把它从AX传送给DS。当然也可通过堆栈来做。

- **ES**，**附加段**，或附加选择器。这个寄存器的低16-bit连同EDI一同**指向指令将要处理的内存**。其他同DS。

- **FS**，F段或F选择器。可以用这个寄存器作为默认段寄存器或选择器的一个**替代品**。

- **GS**，G段或G选择器。它和**FS**几乎完全一样。

- **SS**，堆栈段或堆栈选择器。这个寄存器的低16-bit连同ESP一同**指向下一次堆栈操作（push和pop）所要使用的堆栈地址**。这个寄存器也可以被装入任意数值，可通过入栈和出站操作来赋值。 

- 段寄存器或选择器，在没有指定的情况下都是使用默认的那个。

----

6. 特殊寄存器

----

**EIP**，32-bit，这个寄存器非常重要，同CS一同**指向即将执行的那条指令的地址**。不能够直接修改这个寄存器的值，修改它的唯一方法是跳转或分支指令。（CS是默认的段或选择器）

**ESP**，32-bit，这个寄存器**指向堆栈中即将被操作的那个地址**。尽管可以修改它的值，但并不提倡这样做，可能会破坏堆栈。（SS是默认的段或选择器）

----
7.  标志寄存器

----
![](https://camo.githubusercontent.com/83a9479c16c06d9e0447476fad0294fbe00ca13c/687474703a2f2f6d306e737433722e6d652f7573722f75706c6f6164732f323031372f31312f313937353533333933382e706e67)

----
8.  其他寄存器

----

- :控制寄存器
 - CR0: 切换实模式和保护模式
 - CR2
 - CR3

-  调试寄存器  （可作为调试器的硬件支持来设置条件断点）
 - D0
 - D1
 - D2
 - D3
 - D6
 - D7

- 测试寄存器（用于某些条件测试）
 - TR3
 - TR4
 - TR5
 - TR6
 - TR?


>**第二次学习内容**

----
1. 汇编语言中的整数常量表示

----
- 十进制：直接表示或[十进制数]d或[十进制数]D，是汇编器默认的数制
- 十六进制：0[十六进制数]h或0[十六进制数]H，if(第一位是数字)开头的0可以省略,是汇编程序中最常用的数制
- 二进制：[二进制数]b或[二进制数]B
- 八进制：[八进制数]q、[八进制数]Q、[八进制数]o、[八进制数]O
- 调试器默认使用十六进制表示整数

----
2. 简单指令

----
0)约定

 | 名称 | 含义 | 例 | 
 | :--: | :--: | :--: | 
  | reg32 | 32-bit寄存器 | 如EAX、EBX等 | 
 | reg16 | 16-bit寄存器 | 如AX，BX等 | 
 | reg8 | 8-bit寄存器 | 如AL，BH等 | 
 | imm32 | 32-bit立即数,可以理解为常数 | 
 | imm16 | 16-bit立即数 | 
 | imm8 |  8-bit立即数 | 

1)指令

| 指令 | 含义 | 例子或备注
| :--: | :--: | :--: | 
| MOV | 将数据发送至寄存器中|`mov eax,ebx;`   //将ebx内容送入eax
|xchg|数制交换|`xchg ebx,ecx`   //表示ebx与ecx的数值被交换。
|inc |递增|
|dec |递减|
|add|将寄存器的数值与另一寄存器或立即数的值相加，并存回此寄存器（前）|减法：sub
|lea|写入一个近地址指针|`lea ax,buf;`  //将存储器buf所指的地址传送给ax
|rep|REP指令的作用是重复上面的指令，ECX的值是重复次数。||
|stos|将EAX中的值拷贝到一个目的地址中|
|cmp|比较两个操作数的大小|


注：
 - lea reg16,mem16中，reg16必须是一个16位的通用寄存器，mem16必须是一个存储器。执行完这个指令后，就将mem16所指的16位偏移地址传送到了reg16中。 
 - MOV指令传送的是地址所指的内容，而LEA只是传地址
 - REP指令可以是任何字符串指令（CMPS、LODS、MOVS、SCAS、STOS）的前缀。 REP能够引发其后的字符串指令被重复，只要ECX的值不为0，重复就会继续。每一次字符串指令执行后，ECX的值都会减小
 - STOS(store into string)意思是把EAX的内容拷贝到一个目的地址。 用法：stos dst，dst是一个目的地址，例如stos dword ptr es:[edi]。dword ptr（强制转换成dword格式）前缀是告诉stos，一次拷贝双字（4个字节）到目的地址。
 - cmp（compare）指令进行的运算是第一个操作数减去第二个操作数，但结果不会影响两个操作数的值，只会影响flag的CF、ZF、OF、AF、PF。 对各个flag的影响如下：
  - 若执行指令后
     - ZF=1 这个简单，则说明两个数相等，因为zero为1说明结果为0
  - 当无符号时：
     - CF=1 则说明了有进位或借位，cmp是进行的减操作，故可以看出为借位，所以，此时oprd1<oprd2
      - CF=0 则说明了无借位，但此时要注意ZF是否为0，若为0，则说明结果不为0，故此时oprd1>oprd2
  - 当有符号时：
      - 若SF=0，OF=0 则说明了此时的值为正数，没有溢出，可以直观的看出，oprd1>oprd2
      - 若SF=1，OF=0 则说明了此时的值为负数，没有溢出，则为oprd1<oprd2
      - 若SF=0，OF=1 则说明了此时的值为正数，有溢出，可以看出oprd1<oprd2
      - 若SF=1，OF=1则说明了此时的值为负数，有溢出，可以看出oprd1>oprd2
      - 最后两个可以作出这种判断的原因是，溢出的本质问题：
          - 两数同为正，相加，值为负，则说明溢出
          - 两数同为负，相加，值为正，则说明溢出
          - 故有，正正得负则溢出，负负得正则溢出

----
**跳转指令**

|名称|特性|
|:-:|:-:|
|JMP|无条件跳转|
|JCXZ|CX为0则跳转|
|JECXZ|ECX为0则跳转|
|else|见下文|



	JE   ;等于则跳转
	JNE  ;不等于则跳转
		
	JZ   ;为 0 则跳转
	JNZ  ;不为 0 则跳转

	JS   ;为负则跳转
	JNS  ;不为负则跳转

	JC   ;进位则跳转
	JNC  ;不进位则跳转

	JO   ;溢出则跳转
	JNO  ;不溢出则跳转

	JA   ;无符号大于则跳转
	JNA  ;无符号不大于则跳转
	JAE  ;无符号大于等于则跳转
	JNAE ;无符号不大于等于则跳转

	JG   ;有符号大于则跳转
	JNG  ;有符号不大于则跳转
	JGE  ;有符号大于等于则跳转
	JNGE ;有符号不大于等于则跳转

	JB   ;无符号小于则跳转
	JNB  ;无符号不小于则跳转
	JBE  ;无符号小于等于则跳转
	JNBE ;无符号不小于等于则跳转

	JL   ;有符号小于则跳转
	JNL  ;有符号不小于则跳转
	JLE  ;有符号小于等于则跳转
	JNLE ;有符号不小于等于则跳转

	JP   ;奇偶位置位则跳转
	JNP  ;奇偶位清除则跳转
	JPE  ;奇偶位相等则跳转
	JPO  ;奇偶位不等则跳转


----
3.实模式和保护模式

----

###### i)模式种类

- 从80386开始，cpu有三种工作方式：实模式，保护模式和虚拟8086模式。
- 只有在刚刚启动的时候是real-mode，等到linux操作系统运行起来以后就运行在保护模式。
 - 实模式只能访问地址在1M以下的内存称为常规内存，我们把地址在1M 以上的内存称为扩展内存。
- 在保护模式下，全部32条地址线有效，可寻址高达4G字节的物理地址空间。
-  扩充的存储器分段管理机制和可选的存储器分页管理机制，不仅为存储器共享和保护提供了硬件支持，而且为实现虚拟存储器提供了硬件支持;支持多任务，能够快速地进行任务切换和保护任务环境。
-  4个特权级和完善的特权检查机制，既能实现资源共享又能保证代码和数据的安全和保密及任务的隔离;支持虚拟8086方式，便于执行8086程序。
-   虚拟8086模式是运行在保护模式中的实模式，为了在32位保护模式下执行纯16位程序。它不是一个真正的CPU模式，还属于保护模式。

###### ii)模式区别

- 保护模式同实模式的根本区别是进程内存受保护与否 。
- 可寻址空间的区别只是这一原因的果。

  **【实模式】**
-  将整个物理内存看成分段的区域,程序代码和数据位于不同区域，系统程序和用户程序没有区别对待，而且每一个指针都是指向"实在"的物理地址。
-  这样一来，用户程序的一个指针如果指向了系统程序区域或其他用户程序区域，并改变了值，那么对于这个被修改的系统程序或用户程序，其后果就很可能是灾难性的。
-  为了克服这种低劣的内存管理方式，处理器厂商开发出保护模式。

   **【保护模式】**
-  物理内存地址不能直接被程序访问，程序内部的地址（虚拟地址）要由操作系统转化为物理地址去访问，程序对此一无所知。
-   至此，进程（这时我们可以称程序为进程了）有了严格的边界，任何其他进程根本没有办法访问不属于自己的物理内存区域，甚至在自己的虚拟地址范围内也不是可以任意访问的，因为有一些虚拟区域已经被放进一些公共系统运行库。
-  这些区域也不能随便修改，若修改就会有: 
    -  SIGSEGV（linux 段错误）;
    -  非法内存访问对话框（windows 对话框）。
  
 ----
 
**【补充】**
- 保护模式下，有两个段表：GDT（Global Descriptor Table）和LDT（Local Descriptor Table）。
- 每一张段表可以包含8192 (2^13)个描述符[1]，因而最多可以同时存在2 * 2^13 = 2^14个段。
- 虽然保护模式下可以有这么多段，逻辑地址空间看起来很大，但实际上段并不能扩展物理地址空间，很大程度上各个段的地址空间是相互重叠的。
- 目前所谓的64TB（2^(14+32)=2^46）逻辑地址空间是一个理论值，没有实际意义。
- 在32位保护模式下，真正的物理空间仍然只有2^32字节那 么大。
- 注：在ucore lab中只用到了GDT，没有用LDT。

----

###### iii)64位奔腾4处理器工作模式

- 事实上，现在的64位奔腾4处理器，拥有三种基本模式和一种扩展模式，
    - 基本模式：
        -  保护模式，纯32位保护执行环境。 
        -  实模式：纯16位无保护执行环境。
        -   系统管理模式：当SMI引脚为有效进入系统管理模式，首先保存当前的CPU上下文。它有独立的地址空间，用来执行电源管理或系统安全方面的指令。
    - 扩展模式： IA-32e模式，64位操作系统运行在该模式。 该模式有两种子模式: 
        - 1）兼容模式：该模式下，64位操作系统运行在32位兼容环境，能正常运行16，32位应用程序就像基本的保护模式一样，访问32位地址空间，但不能运行纯16位实模式程序（就是不能运行虚拟86模式程序了）。
        -  2）64位模式：在该模式下，处理器完全执行64位指令，使用64位地址空间和64操作数，运行16，32位程序必须切换到兼容模式。 IA-32e子模式的切换完全基于代码段寄存器。这样一来，运行在IA-32e模式中（64位）的OS完全可以无缝的运行所有16，32，64为应用程序，通过设置32位后的CS。
        
----

>**作业**

把寄存器全部设置成0的状态，然后执行下面的代码：

`ov eax,0a1234h`			将十六进制数0a1234h送入eax

`mov bx,ax`			将ax内容送入bx

`mov ah,bl`			将bl内容送入ah

`mov al,bh`           将bh内容送入al

思考此时EAX的内容是多少?

----
解：

1. 0a1234h=00000000000010100001001000110100b
- 此时
     - eax= 00000000000010100001001000110100
2. bx=ax=0001001000110100b
- 此时
     - eax= 00000000000010100001001000110100
     - ebx= 00000000000000000001001000110100
3. ah=bl=00110100b
- 此时
     - eax= 00000000000010100011010000110100
     - ebx= 00000000000000000001001000110100
4. al=bh=00010010
- 此时
     - eax= 00000000000010100011010000010010
     - ebx= 00000000000000000001001000110100   
5. 综上，此时EAX的内容是a3412
